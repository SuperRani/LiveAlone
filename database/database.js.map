{"version":3,"file":"database.js","sourceRoot":"","sources":["database.ts"],"names":[],"mappings":";AACA,wCAAwC;AACxC,kDAAkD;AAClD,+BAA+B;AAC/B,0DAA0D;AAC1D,6BAA6B;AAC7B,qEAAqE;AAGrE,gCAAgC;AAIhC,EAAE;AACF,8CAA8C;AAC9C,yBAAyB;AACzB,sBAAsB;AACtB,0CAA0C;AAC1C,yCAAyC;AACzC,iCAAiC;AACjC,4BAA4B;AAC5B,gCAAgC;AAChC,mCAAmC;AACnC,kCAAkC;AAClC,cAAc;AACd,QAAQ;AACR,EAAE;AACF,sDAAsD;AACtD,oDAAoD;AACpD,6DAA6D;AAC7D,4BAA4B;AAC5B,mCAAmC;AACnC,oBAAoB;AACpB,uCAAuC;AACvC,kBAAkB;AAClB,cAAc;AACd,SAAS;AACT,EAAE;AACF,+EAA+E;AAC/E,oDAAoD;AACpD,+DAA+D;AAC/D,0BAA0B;AAC1B,mCAAmC;AACnC,mCAAmC;AACnC,kBAAkB;AAClB,aAAa;AACb,QAAQ;AACR,EAAE;AACF,EAAE;AACF,EAAE;AACF,IAAI;AACJ,EAAE;AACF,6BAA6B;AAwB7B,kDAAkD;AAElD,wBAAwB;AACxB,qBAAqB;AACrB,yBAAyB;AACzB,sBAAsB;AACtB,0CAA0C;AAC1C,yCAAyC;AACzC,mCAAmC;AACnC,iCAAiC;AACjC,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,cAAc;AACd,QAAQ;AACR,EAAE;AACF,sCAAsC;AACtC,2CAA2C;AAC3C,oDAAoD;AACpD,4CAA4C;AAC5C,4BAA4B;AAC5B,gBAAgB;AAChB,EAAE;AACF,+EAA+E;AAC/E,mCAAmC;AACnC,mEAAmE;AACnE,2CAA2C;AAC3C,EAAE;AACF,4CAA4C;AAC5C,2CAA2C;AAC3C,EAAE;AACF,oBAAoB;AACpB,yBAAyB;AACzB,wCAAwC;AACxC,oBAAoB;AACpB,kBAAkB;AAClB,cAAc;AACd,QAAQ;AACR,EAAE;AACF,EAAE;AACF,IAAI;AACJ,6CAA6C;AAC7C,mCAAmC;AACnC,EAAE;AAKF,EAAE;AACF,yDAAyD;AACzD,yBAAyB;AACzB,sBAAsB;AACtB,sCAAsC;AACtC,6DAA6D;AAC7D,QAAQ;AACR,EAAE;AACF,sCAAsC;AACtC,oDAAoD;AACpD,4CAA4C;AAC5C,4BAA4B;AAC5B,gBAAgB;AAChB,EAAE;AACF,+EAA+E;AAC/E,mCAAmC;AACnC,gEAAgE;AAChE,2CAA2C;AAC3C,oBAAoB;AACpB,yBAAyB;AACzB,kCAAkC;AAClC,oBAAoB;AACpB,iBAAiB;AACjB,aAAa;AACb,QAAQ;AACR,EAAE;AACF,4CAA4C;AAC5C,oDAAoD;AACpD,4CAA4C;AAC5C,4BAA4B;AAC5B,gBAAgB;AAChB,EAAE;AACF,+EAA+E;AAC/E,mCAAmC;AACnC,2CAA2C;AAC3C,oBAAoB;AACpB,yBAAyB;AACzB,mDAAmD;AACnD,oBAAoB;AACpB,iBAAiB;AACjB,aAAa;AACb,QAAQ;AACR,IAAI;AACJ,EAAE;AACF,6BAA6B;AAYzB,yCAAyC;AACzC,yDAAyD;AAI7D,4CAA4C;AAC5C,EAAE;AACF,EAAE;AACF,gKAAgK;AAChK,mCAAmC;AACnC,iDAAiD;AACjD,kBAAkB;AAClB,eAAe;AACf,EAAE;AACF,wDAAwD;AACxD,4BAA4B;AAC5B,uDAAuD;AACvD,oDAAoD;AACpD,kDAAkD;AAClD,+BAA+B;AAC/B,wCAAwC;AACxC,6BAA6B;AAC7B,8BAA8B;AAC9B,mCAAmC;AACnC,wCAAwC;AACxC,2BAA2B;AAC3B,cAAc;AACd,EAAE;AACF,SAAS;AACT,IAAI;AAKA,yBAAyB;AACzB,uCAAuC;AACvC,QAAQ;AACR,IAAI;AACJ,wDAAwD;AACxD,wBAAwB;AACxB,mDAAmD;AACnD,oBAAoB;AACpB,+CAA+C;AAC/C,gCAAgC;AAChC,qEAAqE;AACrE,gCAAgC;AAChC,gCAAgC;AAChC,+BAA+B;AAC/B,oCAAoC;AACpC,uBAAuB;AACvB,UAAU;AACV,yBAAyB;AACzB,0BAA0B;AAC1B,uBAAuB;AACvB,gCAAgC;AAChC,qBAAqB;AACrB,QAAQ;AAwBZ,kDAAkD;AAClD,uCAAuC;AACvC,4DAA4D;AAC5D,EAAE;AACF,8BAA8B;AAC9B,iDAAiD;AACjD,EAAE;AACF,gDAAgD;AAChD,2BAA2B;AAC3B,2DAA2D;AAC3D,+BAA+B;AAC/B,sDAAsD;AACtD,iCAAiC;AACjC,gBAAgB;AAChB,qBAAqB;AACrB,8BAA8B;AAC9B,gBAAgB;AAChB,aAAa;AACb,UAAU;AACV,2BAA2B;AAC3B,wCAAwC;AACxC,wCAAwC;AACxC,8DAA8D;AAC9D,wBAAwB;AACxB,8CAA8C;AAC9C,EAAE;AACF,MAAM;AAEF,eAAe;AAEnB,GAAG","sourcesContent":["\n// import * as Bluebird from 'bluebird';\n// import {createPool,Pool} from 'mysql2/promise';\n// import dbName from './mysql'\n// import {MysqlImp} from \"../@types/gg/myConnectionPool\";\n// import mysql from 'mysql';\n// import {mycpInterface, TEST} from \"../@types/gg/myConnectionPool\";\n\n\n// let mysql = require('mysql');\n\n\n\n//\n// class connectPoolClass implements MysqlImp{\n//     private pool: any;\n//     constructor() {\n//         const mysql = require('mysql');\n//         this.pool = mysql.createPool({\n//             host: 'localhost',\n//             user: 'root',\n//             password: '0000',\n//             database: 'NewTest',\n//             connectionLimit: 10\n//         });\n//     }\n//\n//     public createConnection = (): Promise<any> => {\n//         return new Promise((resolve, reject) => {\n//             this.pool.getConnection((err, connection) => {\n//                 if(err) {\n//                     reject(err);\n//                 }\n//                 resolve(connection);\n//             });\n//         });\n//     };\n//\n//     public query = (connection: any, queryString: string): Promise<any> => {\n//         return new Promise((resolve, reject) => {\n//             connection.query(queryString, (err, result) => {\n//                 if(err)\n//                     reject(err);\n//                 resolve(result);\n//             });\n//         })\n//     }\n//\n//\n//\n// }\n//\n// export = connectPoolClass;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// const pool = mysql.createPool(dbName.database);\n\n// //class 생성방법 ... 실패..\n// class connection {\n//     private pool: any;\n//     constructor() {\n//         const mysql = require('mysql');\n//         this.pool = mysql.createPool({\n//             connectionLimit: 10,\n//             host: \"localhost\",\n//             user: \"root\",\n//             password: \"funple\",\n//             database: \"Account\"\n//         });\n//     }\n//\n//     connect = (): Promise<any> => {\n//         console.log('pool은?', this.pool)\n//         return new Promise((resolve, reject) => {\n//             if(this.pool === undefined) {\n//                 reject();\n//             }\n//\n//             return this.pool!.getConnection((err: any, connection: any) => {\n//                 if(connection) {\n//                     // this.pool!.releaseConnection(connection);\n//                     resolve(connection);\n//\n//                     this.pool!.release();\n//                     resolve(this.pool!);\n//\n//                 }\n//                 else {\n//                     reject(\"failed\");\n//                 }\n//             });\n//         });\n//     }\n//\n//\n// }\n// const exportConnection = new connection();\n// export default exportConnection;\n//\n\n\n\n\n//\n// class MyConnectionPool implements TEST.mycpInterface {\n//     private pool: any;\n//     constructor() {\n//         if(this.pool === undefined)\n//             this.pool = mysql.createPool(dbName.database);\n//     }\n//\n//     connect = (): Promise<any> => {\n//         return new Promise((resolve, reject) => {\n//             if(this.pool === undefined) {\n//                 reject();\n//             }\n//\n//             return this.pool!.getConnection((err: any, connection: any) => {\n//                 if(connection) {\n//                     this.pool!.releaseConnection(connection);\n//                     resolve(this.pool!);\n//                 }\n//                 else {\n//                     reject(\"\");\n//                 }\n//             })\n//         })\n//     }\n//\n//     getConnection = (): Promise<any> => {\n//         return new Promise((resolve, reject) => {\n//             if(this.pool === undefined) {\n//                 reject();\n//             }\n//\n//             return this.pool!.getConnection((err: any, connection: any) => {\n//                 if(connection) {\n//                     resolve(connection);\n//                 }\n//                 else {\n//                     reject(\"connection failed\");\n//                 }\n//             })\n//         })\n//     }\n// }\n//\n// export = MyConnectionPool;\n\n\n\n\n\n\n\n\n    \n    \n    \n    // const promiseMysql = require('mysql');\n    // const pool = promiseMysql.createPool(dbName.database);\n\n\n\n//     export module mysqlConnectionModule {\n//\n//\n//         //connect는 함수입니다     const connect = a => b => c    , a를 입력받아서 (b => c)를 반환합니다.     b => c는 b를 입력받아서 c를 반환하는 함수입니다.     즉 connect는 a를 입력받아서 함수를 반환합니다\n//         //function connect(fn) {\n//         //    return async function(...args) {\n//         //    }\n//         // }\n//\n//     export const connect = fn => async (...args) => {\n//         /* DB 커넥션을 한다. */\n//         const con: any = await pool.getConnection();\n//         /* 로직에 con과 args(넘겨받은 paramter)를 넘겨준다. */\n//         await fn(con, ...args).then(result => {\n//             /* con을 닫아준다. */\n//             con.connection.release();\n//             return result;\n//         }).catch(error => {\n//             /* 에러시 con을 닫아준다. */\n//             con.connection.release();\n//             throw error;\n//         });\n//\n//     };\n// }\n    \n\n\n\n    // function connect(fn) {\n    //     return async function(...args) {\n    //     }\n    // }\n    // export const transaction = fn => async (...args) => {\n    //     /* DB 커넥션을 한다. */\n    //     const con: any = await pool.getConnection();\n    //     /* 트렌젝션 시작 */\n    //     await con.connection.beginTransaction();\n    //     /* 비지니스 로직에 con을 넘겨준다. */\n    //     const result = await fn(con, ...args).catch(async (error) => {\n    //         /* rollback을 진행한다. */\n    //         await con.rollback();\n    //         /* 에러시 con을 닫아준다. */\n    //         con.connection.release();\n    //         throw error;\n    //     });\n    //     /* commit을 해준다. */\n    //     await con.commit();\n    //     /* con을 닫아준다. */\n    //     con.connection.release();\n    //     return result;\n    //     }\n    \n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// export async function connect(): Promise<any> {\n//     // const conn = await connect();\n//     const pool = await mysql.createPool(dbName.database);\n//\n//     //connect()를 매번 호출하지말구요\n//     //connect()는 한번만 호출되고 그 결과를 보관하고 있다가 사용하세요\n//\n//     return new Promise((resolve, reject) => {\n//         //resolve(pool);\n//         return pool.getConnection().then(connection => {\n//             if(connection) {\n//                 pool.releaseConnection(connection);\n//                 resolve(pool);\n//             }\n//             else {\n//                 reject(\"\");\n//             }\n//         })\n//     });\n//     pool.getConnection()\n//                 .then(connection => {\n//                     if (connection) {\n//                         pool.releaseConnection(connection);\n//                     }\n//             console.log('DB IS CONNECTED');\n//\n// });\n    \n    // return pool;\n    \n//}\n\n\n\n"]}